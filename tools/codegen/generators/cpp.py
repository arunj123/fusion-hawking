"""
C++ code generator for Fusion Hawking.

Generates per-service C++ header files with typed service stubs and clients.
The generated stubs inherit from fusion_hawking::RequestHandler so they can
be passed directly to SomeIpRuntime::offer_service().
"""
from .base import AbstractGenerator
from ..models import Struct, Service, Method, Field, Type
import os, re


class CppGenerator(AbstractGenerator):
    def _to_pascal(self, name: str) -> str:
        parts = name.split('_')
        return "".join(p[:1].upper() + p[1:] for p in parts if p)

    def _to_snake(self, name: str) -> str:
        return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()

    def generate(self, structs: list[Struct], services: list[Service], output_dir: str = "build/generated") -> dict[str, str]:
        files = {}
        cpp_dir = os.path.join(output_dir, "cpp")

        # 1. Types header
        if structs:
            files[os.path.join(cpp_dir, "types.h")] = self._generate_types_header(structs)

        # 2. Per-service headers
        for svc in services:
            snake = self._to_snake(svc.name)
            files[os.path.join(cpp_dir, f"{snake}.h")] = self._generate_service_header(svc, structs)

        # 3. bindings.h (umbrella header for backward compat)
        files[os.path.join(cpp_dir, "bindings.h")] = self._generate_umbrella(structs, services)

        return files

    def _generate_umbrella(self, structs: list[Struct], services: list[Service]) -> str:
        lines = [
            "// Auto-generated by Fusion Hawking Codegen -- DO NOT EDIT",
            "// Umbrella header -- includes all service and type headers",
            "#pragma once",
            "",
        ]
        if structs:
            lines.append('#include "types.h"')
        for svc in services:
            snake = self._to_snake(svc.name)
            lines.append(f'#include "{snake}.h"')
        lines.append("")
        return "\n".join(lines)

    def _generate_types_header(self, structs: list[Struct]) -> str:
        # Topological sort to ensure dependencies are defined first
        sorted_structs = self._topological_sort(structs)
        
        lines = [
            "// Auto-generated by Fusion Hawking Codegen -- DO NOT EDIT",
            "#pragma once",
            "#include <vector>",
            "#include <string>",
            "#include <cstdint>",
            "#include <cstring>",
            "",
            "namespace fusion_hawking {",
            "namespace generated {",
            "",
        ]
        for s in sorted_structs:
            pascal = self._to_pascal(s.name)
            lines.append(self._generate_struct(s, pascal))
            lines.append("")
        lines.append("} // namespace generated")
        lines.append("} // namespace fusion_hawking")
        return "\n".join(lines)

    def _topological_sort(self, structs: list[Struct]) -> list[Struct]:
        name_map = {s.name: s for s in structs}
        visited = set()
        result = []

        def visit(s_name):
            if s_name in visited: return
            if s_name not in name_map: return # Primitive or external
            visited.add(s_name)
            # Find dependencies
            s = name_map[s_name]
            for f in s.fields:
                inner_type = f.type
                while inner_type.inner: inner_type = inner_type.inner
                if inner_type.name in name_map:
                    visit(inner_type.name)
            result.append(name_map[s_name])

        for s in structs:
            visit(s.name)
        return result

    def _generate_service_header(self, svc: Service, all_structs: list[Struct]) -> str:
        pasc = self._to_pascal(svc.name)
        guard = f"FUSION_HAWKING_{svc.name.upper()}_H"
        lines = [
            "// Auto-generated by Fusion Hawking Codegen -- DO NOT EDIT",
            f"// Service: {svc.name} (ID: {hex(svc.id)})",
            f"#ifndef {guard}",
            f"#define {guard}",
            "",
            '#include "types.h"',
            "#include <vector>",
            "#include <string>",
            "#include <cstdint>",
            "#include <cstring>",
            "#include <functional>",
            "#include <fusion_hawking/types.hpp>",
            "",
            "// Forward-declare SendRequestGlue for clients",
            "namespace fusion_hawking { std::vector<uint8_t> SendRequestGlue(void* rt, uint16_t sid, uint16_t mid, const std::vector<uint8_t>& payload); }",
            "",
            "namespace fusion_hawking {",
            "namespace generated {",
            "",
        ]

        # Request/Response structs for methods
        for m in svc.methods:
            method_pascal = self._to_pascal(m.name)
            req_name = f"{pasc}{method_pascal}Request"
            lines.append(self._generate_struct(Struct(req_name, m.args), req_name))
            res_name = f"{pasc}{method_pascal}Response"
            res_fields = []
            if m.ret_type.name != "None":
                res_fields.append(Field("result", m.ret_type))
            lines.append(self._generate_struct(Struct(res_name, res_fields), res_name))
            lines.append("")

        # Event structs
        for e in svc.events:
            event_pascal = self._to_pascal(e.name)
            event_name = f"{pasc}{event_pascal}Event"
            lines.append(self._generate_struct(Struct(event_name, e.args), event_name))
            lines.append("")

        # ========== Stub class ==========
        lines.append(f"class {pasc}Stub : public fusion_hawking::RequestHandler {{")
        lines.append("public:")
        lines.append(f"    virtual ~{pasc}Stub() = default;")
        lines.append("")

        lines.append(f"    static constexpr uint16_t SERVICE_ID = 0x{svc.id:04X};")
        lines.append(f"    static constexpr uint8_t MAJOR_VERSION = {svc.major_version};")
        lines.append(f"    static constexpr uint32_t MINOR_VERSION = {svc.minor_version};")
        for m in svc.methods:
            lines.append(f"    static constexpr uint16_t METHOD_{m.name.upper()} = {m.id};")
        for e in svc.events:
            lines.append(f"    static constexpr uint16_t EVENT_{e.name.upper()} = {e.id};")
        for fld in svc.fields:
            if fld.get_id:
                lines.append(f"    static constexpr uint16_t FIELD_GET_{fld.name.upper()} = {fld.get_id};")
            if fld.set_id:
                lines.append(f"    static constexpr uint16_t FIELD_SET_{fld.name.upper()} = {fld.set_id};")
            if fld.notifier_id:
                lines.append(f"    static constexpr uint16_t EVENT_{fld.name.upper()}_NOTIFY = {fld.notifier_id};")
        lines.append("")

        for m in svc.methods:
            method_pascal = self._to_pascal(m.name)
            req_name = f"{pasc}{method_pascal}Request"
            res_name = f"{pasc}{method_pascal}Response"
            lines.append(f"    virtual {res_name} {method_pascal}({req_name} req) = 0;")

        for fld in svc.fields:
            field_pascal = self._to_pascal(fld.name)
            cpp_t = self._cpp_type(fld.type)
            if fld.get_id:
                lines.append(f"    virtual {cpp_t} Get{field_pascal}() {{ return {cpp_t}{{}}; }}")
            if fld.set_id:
                lines.append(f"    virtual void Set{field_pascal}({cpp_t} val) {{}}")
        lines.append("")

        lines.append("    // --- RequestHandler interface ---")
        lines.append(f"    uint16_t get_service_id() override {{ return SERVICE_ID; }}")
        lines.append(f"    uint32_t get_major_version() override {{ return MAJOR_VERSION; }}")
        lines.append(f"    uint32_t get_minor_version() override {{ return MINOR_VERSION; }}")
        lines.append("")
        lines.append("    std::vector<uint8_t> handle(const fusion_hawking::SomeIpHeader& header, const std::vector<uint8_t>& __payload) override {")
        lines.append("        switch (header.method_id) {")

        for m in svc.methods:
            method_pascal = self._to_pascal(m.name)
            req_name = f"{pasc}{method_pascal}Request"
            lines.append(f"            case METHOD_{m.name.upper()}: {{")
            lines.append(f"                {req_name} req;")
            lines.append(f"                if (!__payload.empty()) req.deserialize(__payload.data(), __payload.size());")
            lines.append(f"                auto res = {method_pascal}(req);")
            lines.append(f"                return res.serialize();")
            lines.append(f"            }}")

        for fld in svc.fields:
            field_pascal = self._to_pascal(fld.name)
            cpp_t = self._cpp_type(fld.type)
            if fld.get_id:
                lines.append(f"            case FIELD_GET_{fld.name.upper()}: {{")
                lines.append(f"                auto val = Get{field_pascal}();")
                lines.append(f"                std::vector<uint8_t> out;")
                lines.append(self._serialize_field("val", fld.type, "                "))
                lines.append(f"                return out;")
                lines.append(f"            }}")
            if fld.set_id:
                lines.append(f"            case FIELD_SET_{fld.name.upper()}: {{")
                lines.append(f"                if (!__payload.empty()) {{")
                lines.append(f"                    {cpp_t} val{{}};")
                lines.append(f"                    size_t off = 0;")
                lines.append(f"                    const uint8_t* data = __payload.data();")
                lines.append(f"                    size_t length = __payload.size();")
                lines.append(self._deserialize_field("val", fld.type, "                    "))
                lines.append(f"                    Set{field_pascal}(val);")
                lines.append(f"                }}")
                lines.append(f"                return {{}};")
                lines.append(f"            }}")

        lines.append("            default: return {};")
        lines.append("        }")
        lines.append("    }")
        lines.append("};")
        lines.append("")

        # ========== Client class ==========
        lines.append(f"class {pasc}Client {{")
        lines.append("public:")
        lines.append(f"    static constexpr uint16_t SERVICE_ID = {pasc}Stub::SERVICE_ID;")
        lines.append("")
        lines.append(f"    {pasc}Client(void* runtime, uint16_t service_id)")
        lines.append(f"        : runtime_(runtime), service_id_(service_id) {{}}")
        lines.append("")

        for m in svc.methods:
            method_pascal = self._to_pascal(m.name)
            req_name = f"{pasc}{method_pascal}Request"
            res_name = f"{pasc}{method_pascal}Response"
            args_str = ", ".join([f"{self._cpp_type(a.type)} {a.name}" for a in m.args])
            lines.append(f"    {res_name} {method_pascal}({args_str}) {{")
            lines.append(f"        {req_name} req;")
            for a in m.args:
                lines.append(f"        req.{a.name} = {a.name};")
            lines.append(f"        auto response = fusion_hawking::SendRequestGlue(runtime_, service_id_, {pasc}Stub::METHOD_{m.name.upper()}, req.serialize());")
            lines.append(f"        {res_name} res;")
            lines.append(f"        if (!response.empty()) res.deserialize(response.data(), response.size());")
            lines.append(f"        return res;")
            lines.append(f"    }}")
            lines.append("")

        lines.append("private:")
        lines.append("    void* runtime_;")
        lines.append("    uint16_t service_id_;")
        lines.append("};")
        lines.append("")
        lines.append("} // namespace generated")
        lines.append("} // namespace fusion_hawking")
        lines.append(f"#endif // {guard}")
        return "\n".join(lines)

    def _generate_struct(self, s: Struct, struct_name: str) -> str:
        lines = []
        lines.append(f"struct {struct_name} {{")
        for f in s.fields:
            lines.append(f"    {self._cpp_type(f.type)} {f.name};")
        lines.append("")

        lines.append("    std::vector<uint8_t> serialize() const {")
        lines.append("        std::vector<uint8_t> out;")
        for f in s.fields:
            lines.append(self._serialize_field("this->" + f.name, f.type, "        "))
        lines.append("        return out;")
        lines.append("    }")
        lines.append("")

        # Use __prefix for parameters to avoid shadowing
        lines.append("    size_t deserialize(const uint8_t* __data, size_t __length) {")
        lines.append("        size_t off = 0;")
        # Provide aliases to stay compatible with generated field serialization logic
        lines.append("        const uint8_t* data = __data;")
        lines.append("        size_t length = __length;")
        for f in s.fields:
            lines.append(self._deserialize_field("this->" + f.name, f.type, "        "))
        lines.append("        return off;")
        lines.append("    }")
        lines.append("")

        lines.append(f"    static {struct_name} from_bytes(const uint8_t* __data, size_t __length) {{")
        lines.append(f"        {struct_name} obj;")
        lines.append(f"        obj.deserialize(__data, __length);")
        lines.append(f"        return obj;")
        lines.append(f"    }}")
        lines.append("};")
        return "\n".join(lines)

    def _serialize_field(self, name: str, t: Type, indent: str) -> str:
        lines = []
        if t.inner:
            lines.append(f"{indent}{{")
            lines.append(f"{indent}  std::vector<uint8_t> payload;")
            lines.append(f"{indent}  for (const auto& item : {name}) {{")
            inner_lines = self._serialize_field("item", t.inner, indent + "    ")
            lines.append(inner_lines.replace("out.push_back", "payload.push_back").replace("out.insert", "payload.insert").replace("out.end()", "payload.end()"))
            lines.append(f"{indent}  }}")
            lines.append(f"{indent}  uint32_t len = static_cast<uint32_t>(payload.size());")
            lines.append(f"{indent}  out.push_back((len >> 24) & 0xFF); out.push_back((len >> 16) & 0xFF);")
            lines.append(f"{indent}  out.push_back((len >> 8) & 0xFF); out.push_back(len & 0xFF);")
            lines.append(f"{indent}  out.insert(out.end(), payload.begin(), payload.end());")
            lines.append(f"{indent}}}")
        elif t.name in ('int', 'int32'):
            lines.append(f"{indent}{{ int32_t v = {name}; out.push_back((v >> 24) & 0xFF); out.push_back((v >> 16) & 0xFF); out.push_back((v >> 8) & 0xFF); out.push_back(v & 0xFF); }}")
        elif t.name in ('float', 'float32'):
            lines.append(f"{indent}{{ uint32_t v; std::memcpy(&v, &{name}, 4); out.push_back((v >> 24) & 0xFF); out.push_back((v >> 16) & 0xFF); out.push_back((v >> 8) & 0xFF); out.push_back(v & 0xFF); }}")
        elif t.name in ('double', 'float64'):
            lines.append(f"{indent}{{ uint64_t v; std::memcpy(&v, &{name}, 8); for (int i = 7; i >= 0; --i) out.push_back((v >> (i*8)) & 0xFF); }}")
        elif t.name == 'bool':
            lines.append(f"{indent}out.push_back({name} ? 1 : 0);")
        elif t.name in ('string', 'str'):
            lines.append(f"{indent}{{ uint32_t len = static_cast<uint32_t>({name}.size()); out.push_back((len >> 24) & 0xFF); out.push_back((len >> 16) & 0xFF); out.push_back((len >> 8) & 0xFF); out.push_back(len & 0xFF); out.insert(out.end(), {name}.begin(), {name}.end()); }}")
        else:
            lines.append(f"{indent}{{ auto sub = {name}.serialize(); out.insert(out.end(), sub.begin(), sub.end()); }}")
        return "\n".join(lines)

    def _deserialize_field(self, name: str, t: Type, indent: str) -> str:
        lines = []
        if t.inner:
            lines.append(f"{indent}if (off + 4 <= length) {{")
            lines.append(f"{indent}  uint32_t byte_len = (data[off] << 24) | (data[off+1] << 16) | (data[off+2] << 8) | data[off+3]; off += 4;")
            lines.append(f"{indent}  uint32_t end_off = off + byte_len;")
            lines.append(f"{indent}  {name}.clear();")
            lines.append(f"{indent}  while (off < end_off && off < length) {{")
            if t.inner.name in ('int', 'int32', 'float', 'float32', 'double', 'float64', 'bool', 'string', 'str'):
                lines.append(f"{indent}    {self._cpp_type(t.inner)} item{{}};")
                lines.append(self._deserialize_field("item", t.inner, indent + "    "))
                lines.append(f"{indent}    {name}.push_back(item);")
            else:
                lines.append(f"{indent}    {self._cpp_type(t.inner)} item{{}};")
                lines.append(f"{indent}    off += item.deserialize(data + off, length - off);")
                lines.append(f"{indent}    {name}.push_back(item);")
            lines.append(f"{indent}  }}")
            lines.append(f"{indent}}}")
        elif t.name in ('int', 'int32'):
            lines.append(f"{indent}if (off + 4 <= length) {{ {name} = (data[off] << 24) | (data[off+1] << 16) | (data[off+2] << 8) | data[off+3]; off += 4; }}")
        elif t.name in ('float', 'float32'):
            lines.append(f"{indent}if (off + 4 <= length) {{ uint32_t v = (data[off] << 24) | (data[off+1] << 16) | (data[off+2] << 8) | data[off+3]; std::memcpy(&{name}, &v, 4); off += 4; }}")
        elif t.name in ('double', 'float64'):
            lines.append(f"{indent}if (off + 8 <= length) {{ uint64_t v = 0; for(int i=0;i<8;++i) v = (v<<8)|data[off+i]; std::memcpy(&{name}, &v, 8); off += 8; }}")
        elif t.name == 'bool':
            lines.append(f"{indent}if (off < length) {{ {name} = data[off] != 0; off += 1; }}")
        elif t.name in ('string', 'str'):
            lines.append(f"{indent}if (off + 4 <= length) {{ uint32_t slen = (data[off]<<24)|(data[off+1]<<16)|(data[off+2]<<8)|data[off+3]; off += 4;")
            lines.append(f"{indent}  if (off + slen <= length) {{ {name} = std::string(reinterpret_cast<const char*>(data+off), slen); off += slen; }} }}")
        else:
            lines.append(f"{indent}off += {name}.deserialize(data + off, length - off);")
        return "\n".join(lines)

    def _cpp_type(self, t: Type, is_return=False) -> str:
        if t.inner: return f"std::vector<{self._cpp_type(t.inner)}>"
        mapping = {'int':'int32_t','int8':'int8_t','int16':'int16_t','int32':'int32_t','int64':'int64_t','uint8':'uint8_t','uint16':'uint16_t','uint32':'uint32_t','uint64':'uint64_t','float':'float','float32':'float','float64':'double','double':'double','string':'std::string','str':'std::string','bool':'bool','None':'void'}
        if t.name in mapping: return mapping[t.name]
        return self._to_pascal(t.name)
