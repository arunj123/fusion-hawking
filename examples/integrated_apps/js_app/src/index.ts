
import { SomeIpRuntime, LogLevel } from 'fusion-hawking';
import * as path from 'path';
// Import from generated TS bindings (generated by Fusion Hawking codegen)
import { MathServiceClient } from './generated/math_service.js';
import { StringServiceClient } from './generated/string_service.js';
import { DiagnosticServiceClient } from './generated/diagnostic_service.js';

async function main() {
    console.log("=== Integrated JS Application ===");

    // Path to config in parent directory
    const defaultPath = path.resolve('../config.json');
    const configPath = process.argv[2] ? path.resolve(process.argv[2]) : defaultPath;
    console.log(`Using config from: ${configPath}`);

    const runtime = new SomeIpRuntime();
    // Load configuration
    await runtime.loadConfigFile(configPath, 'js_app_instance');

    runtime.getLogger().log(LogLevel.INFO, "Main", "JS Runtime Starting...");
    runtime.start();

    // Allow time for SD
    runtime.getLogger().log(LogLevel.INFO, "Main", "Waiting 5s for Service Discovery...");
    await new Promise(r => setTimeout(r, 5000));

    // 1. Call Rust Math Service (UDP)
    try {
        const mathClient = new MathServiceClient(runtime, 'math-client');
        runtime.getLogger().log(LogLevel.INFO, "Client", "Calling Math.Add(10, 20)...");
        const result = await mathClient.add(10, 20);
        runtime.getLogger().log(LogLevel.INFO, "Client", `Result (UDP): ${result}`);
    } catch (e) {
        runtime.getLogger().log(LogLevel.ERROR, "Client", `Math UDP Failed: ${e}`);
    }

    // 2. Call Python Math Service (TCP)
    try {
        const mathTcpClient = new MathServiceClient(runtime, 'math-client-tcp');
        runtime.getLogger().log(LogLevel.INFO, "Client", "Calling Math.Add(50, 50) via TCP...");
        const result = await mathTcpClient.add(50, 50);
        runtime.getLogger().log(LogLevel.INFO, "Client", `Result (TCP): ${result}`);
    } catch (e) {
        runtime.getLogger().log(LogLevel.ERROR, "Client", `Math TCP Failed: ${e}`);
    }

    // 3. Call Python String Service (UDP)
    try {
        const stringClient = new StringServiceClient(runtime, 'string-client');
        runtime.getLogger().log(LogLevel.INFO, "Client", "Calling String.Reverse('Hello JS')...");
        const rev = await stringClient.reverse('Hello JS');
        runtime.getLogger().log(LogLevel.INFO, "Client", `Result string: '${rev}'`);
    } catch (e) {
        runtime.getLogger().log(LogLevel.ERROR, "Client", `String Failed: ${e}`);
    }

    // 4. Call Python Diagnostic Service (TCP)
    try {
        const diagClient = new DiagnosticServiceClient(runtime, 'diag-client');
        runtime.getLogger().log(LogLevel.INFO, "Client", "Calling Diag.GetVersion()...");
        const ver = await diagClient.get_version();
        runtime.getLogger().log(LogLevel.INFO, "Client", `Result (TCP): '${ver}'`);
    } catch (e) {
        runtime.getLogger().log(LogLevel.ERROR, "Client", `Diag Failed: ${e}`);
    }

    // Keep alive
    setTimeout(() => {
        runtime.getLogger().log(LogLevel.INFO, "Main", "JS App exiting normally.");
        runtime.stop();
        process.exit(0);
    }, 2000);
}

main().catch(console.error);
