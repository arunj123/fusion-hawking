"""
TypeScript code generator for Fusion Hawking.

Generates per-service TypeScript binding files with typed clients and stubs.
Replaces hand-written manual_bindings.ts files.
"""
from .base import AbstractGenerator
from ..models import Struct, Service, Method, Field, Type
import os


class TsGenerator(AbstractGenerator):
    def generate(self, structs: list[Struct], services: list[Service], output_dir: str = "build/generated") -> dict[str, str]:
        files = {}

        # 1. Types file (shared types + serialization helpers)
        if structs:
            files[os.path.join(output_dir, "ts", "types.ts")] = self._generate_types_file(structs)

        # 2. Per-service files
        for svc in services:
            # Collect struct types referenced by this service
            referenced = self._get_referenced_structs(svc, structs)
            filename = self._to_snake(svc.name) + ".ts"
            files[os.path.join(output_dir, "ts", filename)] = self._generate_service_file(svc, referenced, structs)

        # 3. Index file
        files[os.path.join(output_dir, "ts", "index.ts")] = self._generate_index(structs, services)

        return files

    def _generate_types_file(self, structs: list[Struct]) -> str:
        lines = [
            "// Auto-generated by Fusion Hawking Codegen -- DO NOT EDIT",
            "// Shared data types",
            "",
        ]
        for s in structs:
            lines.append(self._generate_struct(s))
            lines.append("")
        
        # Add serialization helpers for these structs
        for s in structs:
            lines.append(self._generate_struct_helpers(s))
            lines.append("")
        return "\n".join(lines)

    def _generate_service_file(self, svc: Service, referenced_structs: list[Struct], all_structs: list[Struct]) -> str:
        lines = [
            "// Auto-generated by Fusion Hawking Codegen -- DO NOT EDIT",
            f"// Service: {svc.name} (0x{svc.id:04X})",
            "",
            "import { SomeIpRuntime, type SomeIpResponse } from 'fusion-hawking';",
        ]

        # Import referenced types and their helpers
        struct_names = []
        for s in referenced_structs:
            struct_names.append(s.name)
            struct_names.append(f"serialize{s.name}")
            struct_names.append(f"deserialize{s.name}")
        
        if struct_names:
            lines.append(f"import {{ {', '.join(struct_names)} }} from './types.js';")
        lines.append("")

        # Request/Response structs
        for m in svc.methods:
            method_pascal = m.name.title().replace('_', '')
            req_name = f"{svc.name}{method_pascal}Request"
            lines.append(self._generate_inline_interface(req_name, m.args))
            if m.ret_type.name != "None":
                lines.append(self._generate_inline_interface(f"{svc.name}{method_pascal}Response", [Field("result", m.ret_type)]))
            lines.append("")

        # Event structs
        for e in svc.events:
            event_pascal = e.name.title().replace('_', '')
            event_name = f"{svc.name}{event_pascal}Event"
            lines.append(self._generate_inline_interface(event_name, e.args))
            lines.append("")

        # Constants
        lines.append(f"export const {svc.name.upper()}_SERVICE_ID = 0x{svc.id:04X};")
        lines.append(f"export const {svc.name.upper()}_MAJOR_VERSION = {svc.major_version};")
        lines.append(f"export const {svc.name.upper()}_MINOR_VERSION = {svc.minor_version};")
        lines.append("")

        # Method/Event ID constants
        for m in svc.methods:
            lines.append(f"export const METHOD_{m.name.upper()} = {m.id};")
        for e in svc.events:
            lines.append(f"export const EVENT_{e.name.upper()} = {e.id};")
        for f in svc.fields:
            if f.get_id:
                lines.append(f"export const FIELD_GET_{f.name.upper()} = {f.get_id};")
            if f.set_id:
                lines.append(f"export const FIELD_SET_{f.name.upper()} = {f.set_id};")
            if f.notifier_id:
                lines.append(f"export const EVENT_{f.name.upper()}_NOTIFY = {f.notifier_id};")
        lines.append("")

        # Client class
        lines.append(f"export class {svc.name}Client {{")
        lines.append(f"    static readonly SERVICE_ID = 0x{svc.id:04X};")
        lines.append(f"    static readonly MAJOR_VERSION = {svc.major_version};")
        lines.append("")
        lines.append("    constructor(private runtime: SomeIpRuntime, private alias: string) {}")
        lines.append("")

        for m in svc.methods:
            method_pascal = m.name.title().replace('_', '')
            args_flat = ", ".join([f"{a.name}: {self._ts_type(a.type)}" for a in m.args])
            ret = self._ts_type(m.ret_type)
            is_ff = getattr(m, 'fire_and_forget', False)

            if is_ff:
                lines.append(f"    async {m.name}({args_flat}): Promise<void> {{")
            else:
                lines.append(f"    async {m.name}({args_flat}): Promise<{ret}> {{")

            lines.append(f"        const payload = this.serialize_{m.name}({', '.join([a.name for a in m.args])});")
            
            # Resolve service IDs and remote endpoint
            lines.append(f"        const ids = this.runtime.getServiceIdAndInstanceByAlias(this.alias);")
            lines.append(f"        if (!ids) throw new Error(`Alias '${{this.alias}}' not found in config`);")
            lines.append(f"        const svc = this.runtime.getRemoteService(ids.serviceId, ids.instanceId);")
            lines.append(f"        if (!svc) throw new Error(`Service for alias '${{this.alias}}' (${{ids.serviceId}}) not discovered`);")

            if is_ff:
                lines.append(f"        await this.runtime.sendRequestNoReturn(")
                lines.append(f"            ids.serviceId, {m.id}, payload, svc.address, svc.port, this.alias")
                lines.append(f"        );")
            else:
                lines.append(f"        const result: SomeIpResponse = await this.runtime.sendRequest(")
                lines.append(f"            ids.serviceId, {m.id}, payload, svc.address, svc.port, 8000, this.alias")
                lines.append(f"        );")

            if not is_ff and m.ret_type.name != "None":
                lines.append(f"        return this.deserialize_{m.name}_response(result.payload);")
            lines.append("    }")
            lines.append("")

            # Serialize helper
            lines.append(f"    private serialize_{m.name}({args_flat}): Buffer {{")
            lines.append( "        const parts: Buffer[] = [];")
            for a in m.args:
                lines.append(self._ts_serialize(a.name, a.type, "        "))
            lines.append( "        return Buffer.concat(parts);")
            lines.append( "    }")
            lines.append("")

            # Deserialize helper
            if not is_ff and m.ret_type.name != "None":
                lines.append(f"    private deserialize_{m.name}_response(data: Buffer): {ret} {{")
                lines.append( "        let off = 0;")
                lines.append(f"        let result: {ret} = null as any;")
                lines.append(self._ts_deserialize("result", m.ret_type, "        "))
                lines.append( "        return result;")
                lines.append( "    }")
                lines.append("")

        lines.append("}")
        return "\n".join(lines)

    def _generate_struct(self, s: Struct) -> str:
        lines = [f"export interface {s.name} {{"]
        for f in s.fields:
            lines.append(f"    {f.name}: {self._ts_type(f.type)};")
        lines.append("}")
        return "\n".join(lines)

    def _generate_struct_helpers(self, s: Struct) -> str:
        lines = []
        # Serialize
        lines.append(f"export function serialize{s.name}(obj: {s.name}): Buffer {{")
        lines.append( "    const parts: Buffer[] = [];")
        for f in s.fields:
            lines.append(self._ts_serialize(f"obj.{f.name}", f.type, "    "))
        lines.append( "    return Buffer.concat(parts);")
        lines.append( "}")
        
        lines.append("")
        
        # Deserialize
        lines.append(f"export function deserialize{s.name}(data: Buffer, offset: number = 0): {{ value: {s.name}, bytesRead: number }} {{")
        lines.append( "    let off = offset;")
        lines.append(f"    const value: any = {{}};")
        for f in s.fields:
            lines.append(self._ts_deserialize(f"value.{f.name}", f.type, "    "))
        lines.append( "    return { value: value as " + s.name + ", bytesRead: off - offset };")
        lines.append( "}")
        
        return "\n".join(lines)

    def _generate_inline_interface(self, name: str, fields: list[Field]) -> str:
        lines = [f"export interface {name} {{"]
        for f in fields:
            lines.append(f"    {f.name}: {self._ts_type(f.type)};")
        lines.append("}")
        return "\n".join(lines)

    def _generate_index(self, structs: list[Struct], services: list[Service]) -> str:
        lines = ["// Auto-generated index -- DO NOT EDIT", ""]
        if structs:
            lines.append("export * from './types.js';")
        for svc in services:
            lines.append(f"export * from './{self._to_snake(svc.name)}.js';")
        lines.append("")
        return "\n".join(lines)

    def _ts_type(self, t: Type) -> str:
        if t.inner:
            return f"{self._ts_type(t.inner)}[]"
        mapping = {
            'int': 'number', 'int8': 'number', 'int16': 'number', 'int32': 'number', 'int64': 'number',
            'uint8': 'number', 'uint16': 'number', 'uint32': 'number', 'uint64': 'number',
            'float': 'number', 'float32': 'number', 'float64': 'number', 'double': 'number',
            'string': 'string', 'str': 'string', 'bool': 'boolean', 'None': 'void',
            'bytes': 'Buffer',
        }
        return mapping.get(t.name, t.name)

    def _ts_serialize(self, expr: str, t: Type, indent: str) -> str:
        lines = []
        if t.inner:
            lines.append(f"{indent}{{ const arr = {expr} || [];")
            lines.append(f"{indent}  const arrBuf = Buffer.concat(arr.map(item => {{")
            lines.append(f"{indent}    const parts: Buffer[] = [];")
            lines.append(self._ts_serialize("item", t.inner, indent + "    "))
            lines.append(f"{indent}    return Buffer.concat(parts);")
            lines.append(f"{indent}  }}));")
            lines.append(f"{indent}  const lenBuf = Buffer.alloc(4); lenBuf.writeUInt32BE(arrBuf.length);")
            lines.append(f"{indent}  parts.push(lenBuf, arrBuf); }}")
        elif t.name in ('int', 'int32'):
            lines.append(f"{indent}{{ const _buf = Buffer.alloc(4); _buf.writeInt32BE({expr}); parts.push(_buf); }}")
        elif t.name in ('float', 'float32'):
            lines.append(f"{indent}{{ const _buf = Buffer.alloc(4); _buf.writeFloatBE({expr}); parts.push(_buf); }}")
        elif t.name in ('double', 'float64'):
            lines.append(f"{indent}{{ const _buf = Buffer.alloc(8); _buf.writeDoubleBE({expr}); parts.push(_buf); }}")
        elif t.name == 'bool':
            lines.append(f"{indent}parts.push(Buffer.from([{expr} ? 1 : 0]));")
        elif t.name in ('str', 'string'):
            lines.append(f"{indent}{{ const s = Buffer.from({expr} || '', 'utf-8');")
            lines.append(f"{indent}  const lb = Buffer.alloc(4); lb.writeUInt32BE(s.length);")
            lines.append(f"{indent}  parts.push(lb, s); }}")
        else:
            # Nested struct
            lines.append(f"{indent}parts.push(serialize{t.name}({expr}));")
        return "\n".join(lines)

    def _ts_deserialize(self, target: str, t: Type, indent: str) -> str:
        lines = []
        safe_target = target.replace('.', '_').replace('[', '_').replace(']', '_')
        if t.inner:
            lines.append(f"{indent}const {safe_target}_byte_len = data.readUInt32BE(off); off += 4;")
            lines.append(f"{indent}const {safe_target}_end = off + {safe_target}_byte_len;")
            lines.append(f"{indent}{target} = [];")
            lines.append(f"{indent}while (off < {safe_target}_end && off < data.length) {{")
            # Inner element deserialization
            lines.append(f"{indent}  let {safe_target}_item: any;")
            lines.append(self._ts_deserialize(f"{safe_target}_item", t.inner, indent + "  "))
            lines.append(f"{indent}  {target}.push({safe_target}_item);")
            lines.append(f"{indent}}}")
        elif t.name in ('int', 'int32'):
            lines.append(f"{indent}{target} = data.readInt32BE(off); off += 4;")
        elif t.name in ('float', 'float32'):
            lines.append(f"{indent}{target} = data.readFloatBE(off); off += 4;")
        elif t.name in ('str', 'string'):
            lines.append(f"{indent}const {safe_target}_len = data.readUInt32BE(off); off += 4;")
            lines.append(f"{indent}{target} = data.slice(off, off + {safe_target}_len).toString('utf-8'); off += {safe_target}_len;")
        elif t.name == 'bool':
            lines.append(f"{indent}{target} = data[off] !== 0; off += 1;")
        else:
            # Nested struct
            lines.append(f"{indent}const {safe_target}_res = deserialize{t.name}(data, off);")
            lines.append(f"{indent}{target} = {safe_target}_res.value;")
            lines.append(f"{indent}off += {safe_target}_res.bytesRead;")
        return "\n".join(lines)

    def _get_referenced_structs(self, svc: Service, all_structs: list[Struct]) -> list[Struct]:
        """Find all struct types referenced by a service."""
        names = set()
        for m in svc.methods:
            for a in m.args:
                self._collect_type_names(a.type, names)
            self._collect_type_names(m.ret_type, names)
        for e in svc.events:
            for a in e.args:
                self._collect_type_names(a.type, names)
        for f in svc.fields:
            self._collect_type_names(f.type, names)
        return [s for s in all_structs if s.name in names]

    def _collect_type_names(self, t: Type, names: set):
        if t.inner:
            self._collect_type_names(t.inner, names)
        elif t.name not in ('int', 'int8', 'int16', 'int32', 'int64',
                           'uint8', 'uint16', 'uint32', 'uint64',
                           'float', 'float32', 'float64', 'double',
                           'string', 'str', 'bool', 'None', 'bytes', 'list'):
            names.add(t.name)

    @staticmethod
    def _to_snake(name: str) -> str:
        """Convert PascalCase to snake_case."""
        import re
        return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()
